<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>example</title>
    <link rel="stylesheet" href="assets/css/github-markdown.css">
    <style>
      body {
        min-width: 200px;
        max-width: 790px;
        margin: 0 auto;
        padding: 30px;
      }
    </style>
  </head>
  <body>
    <article class="markdown-body">
      <p><small><em>This file is part of LEANER. To know more, view the source code <a href="../src/lib.py">lib.py</a> or read our <a href="https://github.com/ai-se/leaner">home</a> page.</em></small></p>
<a name="general_stuff"></a><h1>General stuff<a class="anchorlink" href="#general_stuff"></a></h1>
<pre class="prettyprint">from config import *
import random,math

@setting
def LIB(**d): return o(
    # Thresholds are from http://goo.gl/25bAh9
    dull = [0.147, 0.33, 0.474][0]
  ).update(**d)</pre>
<a name="type_stuff"></a><h2>Type stuff<a class="anchorlink" href="#type_stuff"></a></h2>
<pre class="prettyprint">def identity(x): return x
def ako(x,y)   : return isinstance(x,y)
def isList(x)  : 
  return x if isinstance(x,list) else [x]
def isSet(x): 
  return x if isinstance(x,set) else set([x])
def myIntersect(x,y):
  if isinstance(x,(str,int,float)): x = [x]
  if isinstance(y,(str,int,float)): y = [y]
  return [val for val in x if val in y]</pre>
<a name="math_stuff"></a><h2>Math stuff<a class="anchorlink" href="#math_stuff"></a></h2>
<pre class="prettyprint">pi=math.pi
e=math.e
sqrt=math.sqrt
log=math.log

def mult(lst): return reduce(lambda x,y: x*y,lst)</pre>
<a name="random_stuff"></a><h2>Random stuff<a class="anchorlink" href="#random_stuff"></a></h2>
<pre class="prettyprint">r     = random.random
rseed = random.seed

def ask(x):
  return random.choice(list(x))

def shuffle(lst): random.shuffle(lst); return lst

def normpdf(x, mu=0, sigma=1):
  u = (x-mu) /abs( sigma)
  y = e**(-u*u/2) / (sqrt(2*pi) * abs(sigma))
  return y</pre>
<p>List stuff</p>
<pre class="prettyprint">def first(lst): return lst[0]
def second(lst): return lst[1]
def last(lst): return lst[-1]</pre>
<a name="misc_stuff"></a><h1>Misc stuff<a class="anchorlink" href="#misc_stuff"></a></h1>
<pre class="prettyprint">def msecs(f):
  import datetime
  t1 = datetime.datetime.now()
  f()
  t2 = datetime.datetime.now() - t1
  return t2.total_seconds()</pre>
<a name="iterator_stuff"></a><h2>Iterator Stuff<a class="anchorlink" href="#iterator_stuff"></a></h2>
<p>Return all pairs of items i,i+1 from a list.</p>
<pre class="prettyprint">def pairs(lst):

  last=lst[0]
  for i in lst[1:]:
    yield last,i
    last = i</pre>
<p>Return counts of consecutively repeated items in a list.</p>
<pre class="prettyprint">def runs(lst):
  for j,two in enumerate(lst):
    if j == 0:
      one,i = two,0
    if one!=two:
      yield j - i,one
      i = j
    one=two
  yield j - i + 1,two</pre>
<a name="stats_stuff"></a><h2>Stats stuff<a class="anchorlink" href="#stats_stuff"></a></h2>
<p>Cliff&#39;s delta computes the probability that one list
has numbers bigger or smaller than another
list. This version sorts the lists before making
that test. For lists containing 100,1000,10000
random numbers, this implementations
is  one to three orders
of magnitude faster
than another version that does not
use sorting.</p>
<pre class="prettyprint">def cliffsDelta(lst1,lst2,dull=None):
  dull = dull or the.LIB.dull
  m, n = len(lst1), len(lst2)
  lst2 = sorted(lst2)
  j = more = less = 0
  for repeats,x in runs(sorted(lst1)):
    while j &lt;= (n - 1) and lst2[j] &lt;  x: 
      j += 1
    more += j*repeats
    while j &lt;= (n - 1) and lst2[j] == x: 
      j += 1
    less += (n - j)*repeats
  d= (more - less) / (m*n)
  return abs(d)  &gt; dull</pre>
<a name="printing_stuff"></a><h2>Printing stuff<a class="anchorlink" href="#printing_stuff"></a></h2>
<p>Print one or more of anything (no new lines).</p>
<pre class="prettyprint">def say(*l):
  sys.stdout.write(&#39;, &#39;.join(map(str,l)))</pre>
<p>Print list of numbers without too many decimal places.</p>
<pre class="prettyprint">def g(lst,n=3):
  for col,val in enumerate(lst):
    if isinstance(val,float): 
      val = round(val,n) if n else int(val)
    lst[col] = val
  return lst</pre>
<p>Print a list of lists, aligning all the columns.</p>
<pre class="prettyprint">def printm(matrix,sep=&#39; | &#39;):
  s = [[str(e) for e in row] for row in matrix]
  lens = [max(map(len, col)) for col in zip(*s)]
  fmt = sep.join(&#39;{{:{}}}&#39;.format(x) for x in lens)
  for row in [fmt.format(*row) for row in s]:
    print(row)</pre>
<p>Print a list of numbers (possibly
unsorted) 
 and presents them as a horizontal
 percentile chart (in ascii format). The default is a 
  contracted <em>quintile</em> that shows the 
  10,30,50,70,90 breaks in the data (but this can be 
  changed- see the optional flags of the function)</p>
<pre class="prettyprint">def xtile(lst,lo=0,hi=100,width=50,
             chops=[0.1 ,0.3,0.5,0.7,0.9],
             marks=[&quot;-&quot; ,&quot; &quot;,&quot; &quot;,&quot;-&quot;,&quot; &quot;],
             bar=&quot;|&quot;,star=&quot;*&quot;,show=&quot; %3.0f&quot;):
  def pos(p)   : return ordered[int(len(lst)*p)]
  def place(x) : 
    return int(width*float((x - lo))/(hi-lo+0.001))
  def pretty(lst) : 
    return &#39;, &#39;.join([show % x for x in lst])
  ordered = sorted(lst)
  lo      = min(lo,ordered[0])
  hi      = max(hi,ordered[-1])
  what    = [pos(p)   for p in chops]
  where   = [place(n) for n in  what]
  out     = [&quot; &quot;] * width
  for one,two in pairs(where):
    for i in range(one,two): 
      out[i] = marks[0]
    marks = marks[1:]
  out[int(width/2)]    = bar
  out[place(pos(0.5))] = star 
  return &#39;(&#39;+&#39;&#39;.join(out) +  &quot;),&quot; +  pretty(what)</pre>
<a name="demo_stuff"></a><h2>Demo Stuff<a class="anchorlink" href="#demo_stuff"></a></h2>
<pre class="prettyprint">def go(d):
  doc= &#39;# &#39;+d.__doc__+&quot;\n&quot; if d.__doc__ else &quot;&quot;
  s=&#39;|&#39;+&#39;=&#39;*40 +&#39;\n&#39;
  print(&#39;\n==|&#39;,d.func_name + &#39; &#39; + s+doc)
  try:
    d()
  except:
    print(&#39;Demo function did not crash: False&#39;)
  return d</pre>

    </article>
  </body>
</html>
