<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>example</title>
    <link rel="stylesheet" href="assets/css/github-markdown.css">
    <style>
      body {
        min-width: 200px;
        max-width: 790px;
        margin: 0 auto;
        padding: 30px;
      }
    </style>
  </head>
  <body>
    <article class="markdown-body">
      <p><small><em>This file is part of LEANER. To know more, view the source code <a href="../src/column.py">column.py</a> or read our <a href="https://github.com/ai-se/leaner">home</a> page.</em></small></p>
<a name="defining_columns"></a><h1>Defining columns<a class="anchorlink" href="#defining_columns"></a></h1>
<pre class="prettyprint">from lib import *

@setting
def COL(**d): return o(
# Thresholds are from http://goo.gl/25bAh9
    buffer = 128,
    m = 2,
    k = 1,
    missing=&#39;?&#39;
    ).update(**d)</pre>
<h3><code>Column</code>: Generic Columns</h3>
<p><code>Column</code>s keep track of what was seen in a column.
The general idea is that:</p>
<ul class="list">
<li><em>Before</em> you start reading data,
you create one <code>Column</code> for each column. </li>
<li><em>After</em> the data has been read, a column can be
 <code>ask()</code>ed  for a representative on what
 values have been observed.</li>
<li><em>While</em> reading data, the columns peek at each
seen value (and update their information accordingly).
This is called <code>tell()</code>ing the column about a value.</li>
</ul>
<pre class="prettyprint">class Column:
  def tell(i,x):
    if x is None or x == the.COL.missing:
      return x
    i.n += 1
    i.tell1(x)
    return x</pre>
<p>Also, you can ask a <code>Column</code> for:</p>
<ul class="list">
<li>The distance between two col values (normalized 0 to 1)</li>
<li>A <code>logger()</code>; i.e
a new column for storing things like this column.</li>
</ul>
<p>Finally, a <code>Column</code> can tell you how <code>likely()</code> is some
value, given the <code>tell()</code>ed values of that column.</p>
<h2><code>S</code>: Columns of Symbols</h2>
<p>Tracks the frequency counts of the <code>tell()</code>ed symbols.
Can report the entropy <code>ent()</code> of that distribution
(which is a measure of the diversity of those symbols).</p>
<pre class="prettyprint">class S(Column): 
  def __init__(i,all=None,name=&#39;&#39;): 
    i.all = {}
    print(&#39;all&#39;,i.all)
    i.n = 0
    i.name = str(name)
    map(i.tell,all)
  def tell1(i,x)  : 
    i.all[x] = i.all.get(x,0) + 1
  def ask(i)     : return(ask(i.all.keys()))
  def dist(i,x,y): return 0 if x==y else 1
  def norm(i,x)  : return x
  def logger(i)  : return S(name=i.name)
  def read(i,x)  : return x
  def ent(i):
    e=0
    for key,value in i.all.items():
      if value &gt; 0:
        p = value/i.n
      e -= p*log(p,2)
    return e
  def likely(i,x,prior=1):
    m = the.COL.m
    return (i.all.get(x,0) + m*prior)/(i.n + m)</pre>
<p>In <code>likely()</code>, the <code>prior</code> value is some used in a Naive Bayes
classifier (details later).</p>
<h2><code>N</code>: Columns of Numbers</h2>
<p>Numeric columns track the <code>lo</code> and <code>hi</code> of the <code>tell()</code>ed
numbers as well as their mean <code>mu</code> and standard deviation
<code>sd()</code>.</p>
<p><code>N</code>s  also keep <code>kept()</code> a random sampling
of the numbers (up to a max of <code>the.COL.buffer</code> numbers).</p>
<pre class="prettyprint">class N(Column):
  def __init__(i,init=[],lo=None,hi=None,name=&#39;&#39;):
    i.n, i.lo, i.hi, i.name = 0,lo,hi,str(name)
    i._kept = [None]*the.COL.buffer
    i.mu = i.m2= 0
    map(i.tell,init)
  def __repr__(i): 
    return &#39;{:%s #%s [%s .. %s]}&#39;%(
      i.name,i.n,i.lo ,i.hi)
  def ask(i): 
    return i.lo + r()*(i.hi - i.lo)
  def dist(i,x,y): 
    return i.norm(x) - i.norm(y)
  def mediqr(i):
    lst = i.kept()
    q = int(len(lst)/4)
    return lst[q*2], lst[q*3] - lst[q]
  def q2q3(i): 
    lst = i.kept()
    q   = int(len(lst)/4)
    return lst[q*2], lst[q*3]
  def kept(i): 
    return sorted([x for x in i._kept if x is not None])
  def likely(i,x,prior=None):
    return normpdf(x,i.mu,i.sd())
  def logger(i): 
    return N(name=i.name,lo=i.lo,hi=i.hi)
  def norm(i,x):
    tmp =(x - i.lo) / (i.hi - i.lo + 0.00001)
    return max(0,min(tmp,1))
  def read(i,x): 
    return float(x)
  def sd(i):
    if i.n &lt; 2: return 0
    return (max(0,i.m2)/(i.n - 1))**0.5
  def tell1(i,x):
    if i.lo is None: i.lo = x
    if i.hi is None: i.hi = x
    i.lo, i.hi = min(i.lo,x), max(i.hi,x)
    delta = x - i.mu
    i.mu += delta/i.n
    i.m2 += delta*(x - i.mu)
    l = len(i._kept)
    if r() &lt;= l/i.n: i._kept[ int(r()*l) ]= x</pre>

    </article>
  </body>
</html>
